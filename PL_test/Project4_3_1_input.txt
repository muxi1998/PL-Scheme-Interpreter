1
(define a "=============== Problem 3 viewable case =================")
a
( clean-environment )

; Expert System Shell - complex

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Utilities ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; car               ; first one
 
( define ( cadr x ) ; second one

  ( car ( cdr x ) )
  
);define cadr

( define ( caddr x ) ; third one

  ( car ( cdr ( cdr x ) ) )
   
);define caddr

( define ( caar x ) ; 'car' of first one

  ( car ( car x ) )
  
);define caar

( define ( caadr x ) ; 'car' of second one

  ( car ( cadr x ) )
  
);define caar

( define ( caaddr x ) ; 'car' of third one

  ( car ( caddr x ) )
   
);define caaddr

;=========================== Utilities ===============================

( define ( % original divider )

  ( cond ( ( not ( integer? original ) )
           ( create-error-object ( string-append "% : " ( number->string original )
                                                 " is not an integer."
                                 )
           )
         )
         ( ( not ( integer? divider ) )
           ( create-error-object ( string-append "% : " ( number->string divider )
                                                 " is not an integer."
                                 )
           )
         )
         ( else
           ( - original ( * ( / original divider )
                            divider
                        )
           )
         );else
         
  );cond
  
);define %

; Use the following definition of '%' when running Petite-Scheme (SWL)
;
; ( define ( % original divider )
;   ( modulo original divider )
; );define %

( define $%%% 379 )

( define ( KeyPair original )
  
  ( if ( < original $%%% )
    ( create-error-object ( string-append "Please use a number greater than "
                                          ( number->string $%%% )
                                          " as key."
                          )
    )
    ( cons ( % original $%%% )
           ( list original )
    )
  );if
  
);define KeyPair

( define ( RealKey original )

; the "key" defined by KeyPair from 'original'
  
  ( if ( < original $%%% )
    
    original
    
    ( % original $%%% )

  );if
  
);define RealKey

;=========================== Utilities ===============================

( define ( ListAppend firstList secondList )

  ( cond ( ( and ( atom? firstList )
                 ( not ( null? firstList ) )
           )
           ( create-error-object "( ListAppend firstList secondList ) : First one must be a list." )
         )
         ( ( and ( atom? secondList )
                 ( not ( null? secondList ) )
           )
           ( create-error-object "( ListAppend firstList secondList ) : Second one must be a list." )
         )
    ( else 
      ( $ListAppend firstList secondList )
    )
    
  );cond
  
);define ListAppend

( define ( $ListAppend firstList secondList )
; prerequisite: both 'firstList' and 'secondList' are lists (including the case of '())

  ( if ( null? firstList )
  
      secondList
      
      ( cons ( car firstList )
             ( $ListAppend ( cdr firstList )
                           secondList
             )
      );cons
      
  );if

);define ListAppend

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( ListLength s-expr )

  ( cond 
  
    ( ( null? s-expr ) 0 )
    
    ( ( atom? s-expr ) ( create-error-object "( ListLength s-expr ) : s-expr is a non-'() atom" )
    )
    
    ( else ( $ListLength s-expr )
    )
    
  );cond
  
);define ListLength
                           
( define ( $ListLength aList )

; prerequisite: aList is either a non-empty list (i.e., it must not be '()) 
;                        or a dotted pair

  ( let ( ( remaining ( cdr aList ) )
        );local 
        
    ( if ( atom? remaining ) ; either '() or a real atom, which means that aList is not really a list
    
         1
         
         ( + 1 ( $ListLength remaining ) 
         )
         
    );if
    
  );let
  
);define $ListLength
                           
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( NthElementOf n s-expr )

  ( cond
  
    ( ( not ( integer? n ) ) 
      ( create-error-object "( NthElementOf n s-expr ) : Illegal first argument!" )
    )
    
    ( ( < n 1 )
      ( create-error-object "( NthElementOf n s-expr ) : Illegal first argument!" )
    )
    
    ; assert : n is a natural number
    
    ( ( null? s-expr )
      ( create-error-object "( NthElementOf n s-expr ) : Illegal second argument!" )
    )
    
    ( ( atom? s-expr )
      ( create-error-object "( NthElementOf n s-expr ) : Illegal second argument!" )
    )
    
    ; assert : s-expr is a dotted pair
    
    ( else
      ( $NthElementOf n s-expr )
    )
    
  );cond
  
);define NthElementOf

( define ( $NthElementOf n s-expr )
; prerequisite: n is a natural number and s-expr is a dotted pair (i.e., if list then non-empty)

  ( if ( = n 1 )
  
     ( car s-expr )
     
     ; n > 1
     
     ( let ( ( rest ( cdr s-expr ) )
           );local
           
        ( if ( atom? rest ) ; i.e., no more!
        
            ( create-error-object "( NthElementOf n s-expr ) : Value of n exceeds length of the given s-expression." )
            
            ( $NthElementOf ( - n 1 ) rest )
            
        );if
        
     );let
     
  );if
  
);define $NthElementOf

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( WithNthElementOfListReplaced n aList newElement )

; given 4 and ( a b c d e f g ) and XYZ
; it means: replace the 4TH of ( a b c d e f g ) with XYZ
; result : ( a b c XYZ e f g)

  ( cond ( ( not ( integer? n ) )
           ( create-error-object "( WithNthElementOfListReplaced n aList newElement ) : n is not an integer" )
         )
         ( ( < n 1 ) 
           ( create-error-object "( WithNthElementOfListReplaced n aList newElement ) : n is not a natural number" )
         )
         ( ( < ( ListLength aList ) n )
           ( create-error-object "( WithNthElementOfListReplaced n aList newElement ) : value of n exceeds length of aList" )
         )
         ( else
           ( $WithNthElementOfListReplaced n aList newElement )
         )
  );cond
  
);define WithNthElementOfListReplaced
  
( define ( $WithNthElementOfListReplaced n aList newElement )

; given 4 and ( a b c d e f g ) and XYZ
; it means: replace the 4TH of ( a b c d e f g ) with XYZ
; result : ( a b c XYZ e f g)

  ( if ( = n 1 ) ; we are to replace the first one of 'aList'
  
       ( cons newElement
              ( cdr aList )
       )
       
       ; n > 1
       
       ( let ( ( first ( car aList ) )
               ( new-rest ( $WithNthElementOfListReplaced ( - n 1 ) ( cdr aList ) newElement
                          )
               )
             )
         ( cons first new-rest )
       );let
       
  );if
  
);define $WithNthElementOfListReplaced
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; ( define ( DivisibleBy n factor )
; 
;   ( = n 
;       ( * ( / n factor ) factor )
;   )
;    
; );define DivisibleBy

( define ( DivisibleBy n factor )
  
  ( = ( % n factor )
      0
  )

);define DivisibleBy

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( PrintListOfStringsAsSentence aList )

  ( if ( not ( null? aList ) )
     ( begin
     
       ( display-string ( car aList ) ) 
       ; instead of : 
       ; ( display-string ( eval ( car aList ) ) )
       
       ( display-string " " )
       ( PrintListOfStringsAsSentence ( cdr aList ) )
     )
     ( begin
       ( newline )
       #t
     )
  );if
  
);define PrintListOfStringsAsSentence
     
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( PrintListOfSymbolsAsSentence aList )
; with a LINE-ENTER at the end

  ( if ( not ( null? aList ) )
     ( begin
       ( display-string ( symbol->string ( car aList ) ) )
       ( display-string " " )
       ( PrintListOfSymbolsAsSentence ( cdr aList ) )
     )
     ( begin
       ( newline )
       #t
     )
  );if
  
);define PrintListOfSymbolsAsSentence
     
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( PrintListOfSymbolsStringsAsSentence aList )

  ( if ( not ( null? aList ) )
     ( begin
       ( display-string ( let ( ( element ( car aList ) )
                              );local
                          ( if ( symbol? element )
                               ( symbol->string ( car aList ) ) 
                               element
                          )
                        );let
       )
       ( display-string " " )
       ( PrintListOfSymbolsStringsAsSentence ( cdr aList ) )
     )
     ( begin
       ( newline )
       #t
     )
  );if
  
);define PrintListOfSymbolsStringsAsSentence
     
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( PrintListOfSymbolsNumbersStringsAsSentence aList )

  ( if ( not ( null? aList ) )
     ( begin
       ( display-string ( let ( ( %element ( car aList ) )
                              );local
                          ( cond ( ( symbol? %element )
                                   ( symbol->string %element )
                                 )
                                 ( ( number? %element )
                                   ( number->string %element )
                                 )
                                 ( else 
                                   %element
                                 )
                          )
                        );let
       )
       ( display-string " " )
       ( PrintListOfSymbolsNumbersStringsAsSentence ( cdr aList ) )
     )
     ( begin
       ( newline )
       #t
     )
  );if
  
);define PrintListOfSymbolsNumbersStringsAsSentence
     
;=========================== Utilities ===============================

;=========================== Expert system shell ===============================

( define @size@ 3 )    ;   5 : 'HUGE        'LARGE   'MEDIUM    'SMALL    1 : 'TINY
( define @price@ 3 )   ;   5 : 'EXPENSIVE   'HIGH    'AVERAGE   'LOW      1 : 'VERY-AFFORDABLE 
( define @quality@ 3 ) ;   5 : 'EXCELLENT   'GOOD    'AVERAGE   'BAD      1 : 'TERRIBLE

( define ( ResetTransactionState )

  ( set! @quality@ 3 )
  ( set! @price@ 3 )
  ( set! @size@ 3 )
  #t
  
);define ResetTransactionState

( define ( ProductIndex )
  ( cond ( ( = @quality@ 5 )
           ( + ( - 18 @price@ ) @size@ 3 )                ; max : 25
         )
         ( ( = @quality@ 4 )
           ( + ( - 15 @price@ ) @size@ )                  ; ref. point : 15
         )
         ( ( = @quality@ 3 )
           ( + @price@ @size@ )                           ; average : 6
         )
         ( ( = @quality@ 2 )
           ( - @size@ ( + 4 @price@ ) )                   ; ref. point : -4
         )
         ( ( = @quality@ 1 )
           ( - @size@ ( + 8 @price@ ) )                   ; min : -12
         )
         ( else
           ( create-error-object ( string-append "Invalid @quality@ value : " ( number->string @quality@ )
                                 )
           )
         )
  );cond

);define ProductIndex

( define ( TransactionState )

  ( string-append "quality : " ( number->string @quality@ )
                  " size : "   ( number->string @size@ )
                  " price : "  ( number->string @price@ )
                  " ProductIndex : " ( number->string ( ProductIndex ) )
  )
  
);define TransactionState

( define ( Top? n )
  ( = n 5 )
);define Top?

( define ( Bottom? n )
  ( = n 1 )
);define Bottom?

( define ( TopPrice? )
  ( Top? @price@ )
);define TopPrice?

( define ( BottomPrice? )
  ( Bottom? @price@ )
);define BottomPrice?

( define ( TopSize? )
  ( Top? @size@ )
);define TopSize?

( define ( BottomSize? )
  ( Bottom? @size@ )
);define BottomSize?

( define ( TopQuality? )
  ( Top? @quality@ )
);define TopQuality?

( define ( BottomQuality? )
  ( Bottom? @quality@ )
);define BottomQuality?

( define ( Downgrade n )
  ( if ( = n 1 )
    1
    ( - n 1 )
  )
);define Downgrade

( define ( Upgrade n )
  ( if ( = n 5 )
    5
    ( + n 1 )
  )
);define Downgrade

( define ( DowngradeSize )
  ( set! @size@ ( Downgrade @size@ ) )
);define DowngradeSize

( define ( DowngradePrice )
  ( set! @price@ ( Downgrade @price@ ) )
);define DowngradePrice

( define ( DowngradeQuality )
  ( set! @quality@ ( Downgrade @quality@ ) )
);define DowngradeQuality

( define ( UpgradeSize )
  ( set! @size@ ( Upgrade @size@ ) )
);define UpgradeSize

( define ( UpgradePrice )
  ( set! @price@ ( Upgrade @price@ ) )
);define UpgradePrice

( define ( UpgradeQuality )
  ( set! @quality@ ( Upgrade @quality@ ) )
);define UpgradeQuality

( define ( Abs n )

  ( if ( > n 0 )
    n
    ( * -1 n )
  )
  
);define Abs

( define ( PriceTag income )

  ( let ( ( %type ( % income 3 ) )
        );local

    ( cond
      ( ( = %type 0 ) ; over
      
        ( let ( ( %p ( ProductIndex )
                )
              );local
              
          ( cond 
            ( ( > %p 15 )
              ( + ( * 22000 %p )
                  ( * income 0.4 )
              )
            )
            ( ( > %p 5 )
              ( + ( * 21000 %p )
                  ( * income 0.3 )
              )
            )
            ( ( > %p -5 )
              ( cond ( ( > %p 0 )
                       ( + ( * 20000 %p )
                           ( * income 0.2 )
                       )
                     )
                     ( ( = %p 0 )
                       ( + 19000 ( * income 0.2 ) )
                     )
                     ( else ; %p < 0
                       ( + 19000 ( * %p 500 ) ( * income 0.2 ) )
                     )
              )
            )
            ( ( > %p -13 )
              ( + 19000 ( * %p 600 ) ( * income 0.1 ) )
            )
            ; no ELSE to force error msg.
          );cond
          
        );let %p
        
      ) ; type 0
      
      ( ( = %type 1 ) ; fair
      
        ( let ( ( %p ( ProductIndex )
                )
              );local
              
          ( cond 
            ( ( > %p 15 )
              ( + ( * 20000 %p )
                  ( * income 0.3 )
              )
            )
            ( ( > %p 5 )
              ( + ( * 20000 %p )
                  ( * income 0.2 )
              )
            )
            ( ( > %p -5 )
              ( cond ( ( > %p 0 )
                       ( + ( * 20000 %p )
                           ( * income 0.1 )
                       )
                     )
                     ( ( = %p 0 )
                       ( + 18000 ( * income 0.1 ) )
                     )
                     ( else ; %p < 0
                       ( + 18000 ( * %p 800 ) ( * income 0.1 ) )
                     )
              )
            )
            ( ( > %p -13 )
              ( + 18000 ( * %p 1000 ) ( * income 0.1 ) )
            )
            ; no ELSE to force error msg.
          );cond
          
        );let %p
        
      ) ; type 1
      
      ( ( = %type 2 ) ; low
      
        ( let ( ( %p ( ProductIndex )
                )
              );local
              
          ( cond 
            ( ( > %p 15 )
              ( + ( * 15000 %p )
                  ( * income 0.1 )
              )
            )
            ( ( > %p 5 )
              ( + ( * 15000 %p )
                  ( * income 0.1 )
              )
            )
            ( ( > %p -5 )
              ( cond ( ( > %p 0 )
                       ( + ( * 15000 %p )
                           ( * income 0.1 )
                       )
                     )
                     ( ( = %p 0 )
                       ( + 13000 ( * income 0.1 ) )
                     )
                     ( else ; %p < 0
                       ( + 13000 ( * %p 1000 ) ( * income 0.1 ) )
                     )
              )
            )
            ( ( > %p -13 )
              ( + 13000 ( * %p 1000 ) ( * income 0.1 ) )
            )
            ; no ELSE to force error msg.
          );cond
          
        );let %p
        
      ) ; %type 2
      
    );cond %type
    
  );let %type
    
);define PriceTag

; expertise df= name-0f-the-expertise
;               +
;               list of rules ( a rule-set, implicitly ordered )
;                 where
;                 a rule df= '(' <condition> <action> ')' // multiple actions allowed
;               +
;               evaluation of some corresponding function (a function that can be called)

; For each expertise that exists (i.e., for each name-of-expertise that can be called)
; there is a corresponding entry in the expertise-DB ($expertise-DB).
; This entry df= '(' name-of-expertise <rule> { <rule> } ')'

; for example

( define ( OverSpent n ) ; a function that can be called

  ; Just what is an experise?
  ; an expertise is (in here) an oredered list of rules ( of the form: <condition> -> <action> )

  ( cond
  
    ( ( >= n 200000 )               ; condition
    
      ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
            );local
      
        ( cond   
               
          ( ( and ( <= 300000 %p ) ( <= %p 400000 ) 
            )
            
            #t ; OK
          )
          
          ( ( < %p 300000 )
          
            ( cond
              ( ( not ( TopSize? ) )
                ( UpgradeSize )
              )
              ( ( not ( TopPrice? ) )
                ( UpgradePrice )
              )
              ( ( not ( TopQuality? ) )
                ( UpgradeQuality )
              )
              ; no ELSE 
            );cond
            
          ) ; %p < 300000
          
          ( ( < 400000 %p )
          
            ( cond
              ( ( not ( BottomSize? ) )
                ( DowngradeSize )
              )
              ( ( not ( BottomPrice? ) )
                ( DowngradePrice )
              )
              ( ( not ( BottomQuality? ) )
                ( DowngradeQuality )
              )
              ; no ELSE 
            );cond
            
          ) ; 400000 < %p
          
          ; no ELSE
          
        );cond
        
        ( TransactionState )
        
      );let %p
          
    ) ; condition-action pair 1 with condition : n >= 200000
    
    ( ( >= n 100000 )               ; condition
    
      ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
            );local
      
        ( cond   
               
          ( ( and ( <= 200000 %p ) ( <= %p 300000 ) 
            )
            
            #t ; OK
          )
          
          ( ( < %p 200000 )
          
            ( cond
              ( ( not ( TopSize? ) )
                ( UpgradeSize )
              )
              ( ( not ( TopPrice? ) )
                ( UpgradePrice )
              )
              ( ( not ( TopQuality? ) )
                ( UpgradeQuality )
              )
              ; no ELSE 
            );cond
            
          ) ; %p < 200000
          
          ( ( < 300000 %p )
          
            ( cond
              ( ( not ( BottomSize? ) )
                ( DowngradeSize )
              )
              ( ( not ( BottomPrice? ) )
                ( DowngradePrice )
              )
              ( ( not ( BottomQuality? ) )
                ( DowngradeQuality )
              )
              ; no ELSE 
            );cond
            
          ) ; 300000 < %p
          
          ; no ELSE
          
        );cond
        
        ( TransactionState )
        
      );let %p
          
    ) ; condition-action pair 2 ; with condition : n >= 100000
    
    ( ( >= n 50000 )               ; condition
    
      ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
            );local
      
        ( cond   
               
          ( ( and ( <= 50000 %p ) ( <= %p 100000 ) 
            )
            
            #t ; OK
          )
          
          ( ( < %p 50000 )
          
            ( cond
              ( ( not ( TopSize? ) )
                ( UpgradeSize )
              )
              ( ( not ( TopPrice? ) )
                ( UpgradePrice )
              )
              ( ( not ( TopQuality? ) )
                ( UpgradeQuality )
              )
              ; no ELSE 
            );cond
            
          ) ; %p < 50000
          
          ( ( < 100000 %p )
          
            ( cond
              ( ( not ( BottomSize? ) )
                ( DowngradeSize )
              )
              ( ( not ( BottomPrice? ) )
                ( DowngradePrice )
              )
              ( ( not ( BottomQuality? ) )
                ( DowngradeQuality )
              )
              ; no ELSE 
            );cond
            
          ) ; 100000 < %p
          
          ; no ELSE
          
        );cond
        
        ( TransactionState )
        
      );let %p
          
    ) ; condition-action pair 3 ; with condition : n >= 50000
    
    ( else                         ; condition ( n < 50000 )
    
      ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
            );local
      
        ( cond   
               
          ( ( and ( <= 30000 %p ) ( <= %p 50000 ) 
            )
            
            #t ; OK
          )
          
          ( ( < %p 30000 )
          
            ( cond
              ( ( not ( TopSize? ) )
                ( UpgradeSize )
              )
              ( ( not ( TopPrice? ) )
                ( UpgradePrice )
              )
              ( ( not ( TopQuality? ) )
                ( UpgradeQuality )
              )
              ; no ELSE 
            );cond
            
          ) ; %p < 30000
          
          ( ( < 50000 %p )
          
            ( cond
              ( ( not ( BottomSize? ) )
                ( DowngradeSize )
              )
              ( ( not ( BottomPrice? ) )
                ( DowngradePrice )
              )
              ( ( not ( BottomQuality? ) )
                ( DowngradeQuality )
              )
              ; no ELSE 
            );cond
            
          ) ; 50000 < %p
          
          ; no ELSE
          
        );cond
        
        ( TransactionState )
        
      );let %p
          
    ) ; condition-action pair 3 ; with condition : else (i.e., n < 50000)
    
  );cond
  
);define OverSpent

( define $expertise-DB 

  ; for simplicity, we do not sort this DB by expertise-names for the moment 
  ; (to do that, we will need to use a BST)

  '( ( OverSpent ; name of the expertise ; note that this is a symbol, not a string
     
       ; the list of rules associated with >>OverSpent<<
       
       ( ( >= n 200000 )               ; condition
       
         ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
               );local
         
           ( cond   
                  
             ( ( and ( <= 300000 %p ) ( <= %p 400000 ) 
               )
               
               #t ; OK
             )
             
             ( ( < %p 300000 )
             
               ( cond
                 ( ( not ( TopSize? ) )
                   ( UpgradeSize )
                 )
                 ( ( not ( TopPrice? ) )
                   ( UpgradePrice )
                 )
                 ( ( not ( TopQuality? ) )
                   ( UpgradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; %p < 300000
             
             ( ( < 400000 %p )
             
               ( cond
                 ( ( not ( BottomSize? ) )
                   ( DowngradeSize )
                 )
                 ( ( not ( BottomPrice? ) )
                   ( DowngradePrice )
                 )
                 ( ( not ( BottomQuality? ) )
                   ( DowngradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; 400000 < %p
             
             ; no ELSE
             
           );cond
           
           ( TransactionState )
           
         );let %p
             
       ) ; condition-action pair 1 with condition : n >= 200000
       
       ( ( >= n 100000 )               ; condition
       
         ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
               );local
         
           ( cond   
                  
             ( ( and ( <= 200000 %p ) ( <= %p 300000 ) 
               )
               
               #t ; OK
             )
             
             ( ( < %p 200000 )
             
               ( cond
                 ( ( not ( TopSize? ) )
                   ( UpgradeSize )
                 )
                 ( ( not ( TopPrice? ) )
                   ( UpgradePrice )
                 )
                 ( ( not ( TopQuality? ) )
                   ( UpgradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; %p < 200000
             
             ( ( < 300000 %p )
             
               ( cond
                 ( ( not ( BottomSize? ) )
                   ( DowngradeSize )
                 )
                 ( ( not ( BottomPrice? ) )
                   ( DowngradePrice )
                 )
                 ( ( not ( BottomQuality? ) )
                   ( DowngradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; 300000 < %p
             
             ; no ELSE
             
           );cond
           
           ( TransactionState )
           
         );let %p ; action
             
       ) ; condition-action pair 2 ; with condition : n >= 100000
       
       ( ( >= n 50000 )               ; condition
       
         ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
               );local
         
           ( cond   
                  
             ( ( and ( <= 50000 %p ) ( <= %p 100000 ) 
               )
               
               #t ; OK
             )
             
             ( ( < %p 50000 )
             
               ( cond
                 ( ( not ( TopSize? ) )
                   ( UpgradeSize )
                 )
                 ( ( not ( TopPrice? ) )
                   ( UpgradePrice )
                 )
                 ( ( not ( TopQuality? ) )
                   ( UpgradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; %p < 50000
             
             ( ( < 100000 %p )
             
               ( cond
                 ( ( not ( BottomSize? ) )
                   ( DowngradeSize )
                 )
                 ( ( not ( BottomPrice? ) )
                   ( DowngradePrice )
                 )
                 ( ( not ( BottomQuality? ) )
                   ( DowngradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; 100000 < %p
             
             ; no ELSE
             
           );cond
           
           ( TransactionState )
           
         );let %p ; action
             
       ) ; condition-action pair 3 ; with condition : n >= 50000
       
       ( else                         ; condition ( n < 50000 )
       
         ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
               );local
         
           ( cond   
                  
             ( ( and ( <= 30000 %p ) ( <= %p 50000 ) 
               )
               
               #t ; OK
             )
             
             ( ( < %p 30000 )
             
               ( cond
                 ( ( not ( TopSize? ) )
                   ( UpgradeSize )
                 )
                 ( ( not ( TopPrice? ) )
                   ( UpgradePrice )
                 )
                 ( ( not ( TopQuality? ) )
                   ( UpgradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; %p < 30000
             
             ( ( < 50000 %p )
             
               ( cond
                 ( ( not ( BottomSize? ) )
                   ( DowngradeSize )
                 )
                 ( ( not ( BottomPrice? ) )
                   ( DowngradePrice )
                 )
                 ( ( not ( BottomQuality? ) )
                   ( DowngradeQuality )
                 )
                 ; no ELSE 
               );cond
               
             ) ; 50000 < %p
             
             ; no ELSE
             
           );cond
           
           ( TransactionState )
           
         );let %p ; action
             
       ) ; condition-action pair 3 ; with condition : else (i.e., n < 50000)
    
     );the expertise >>OverSpent<<
     
   ) ; $expertise-DB
   
  ; for each expertise stored in $expertise-DB, 
  ; its CAR is name-of-the-expertise (a symbol), and its CDR is the list-of-rules associated with this "expertise",
  ; with each rule being of the form >>( <condition> <action> )<< ; note again, that multiple actions are allowed
   
);define $expertise-DB

( define ( RuleSetOf expertiseName )

  ( if ( null? $expertise-DB )
  
       ( create-error-object ( string-append ( symbol->string expertiseName ) " not found (expertise-DB is currently empty)" ) )  
         
       ( $RuleSetOfFrom expertiseName $expertise-DB )
  );if
  
);define RuleSetOf

( define ( $RuleSetOfFrom expertiseName list-of-expertise )

; >>expertiseName<< is a symbol
; >>list-of-expertise<< is the list to be searched for the expertise with name being expertiseName ;
; prerequisite: 'list-of-expertise' is a non-empty list

  ( cond
  
    ( ( = ( ListLength list-of-expertise ) 1 )
    
      ( if ( equal? ( car ( car list-of-expertise ) ) expertiseName )
           ( cdr ( car list-of-expertise ) )
           ( create-error-object ( string-append ( symbol->string expertiseName ) " not found in expertise-DB" ) )
      )
    )
    
    ; ListLength > 1
    
    ( else
    
      ( if ( equal? ( car ( car list-of-expertise ) ) expertiseName )
           ( cdr ( car list-of-expertise ) )
           ( $RuleSetOfFrom expertiseName ( cdr list-of-expertise ) )
      )
    )
    
  );cond

);define $RuleSetOfFrom

;;;;;;;;;;;;;;

( define ( WithNthRuleReplaced n ruleList withThisRule )

  ; should do parameter-checks first

  ; ( WithNthElementOfListReplaced n aList newElement )
  
  ( WithNthElementOfListReplaced n ruleList withThisRule )
  
);define WithNthRuleReplaced

( define ( Rule condition action )

  ( list condition action )
  
);define Rule

( define ( DefineExpertise nameOfExpertise listOfRules )

  ( let ( ( %code
            ( list 'define
                   ( cons nameOfExpertise '( n ) )
                   ( cons 'cond listOfRules )
            )
          )
        );local-var
        
    ( eval %code ) ; define the expertise
    
    ; and add its description to the expertise-DB
    
    ( $AddToExpertiseDB nameOfExpertise ( cons nameOfExpertise listOfRules )
    )
    
    ( PrintListOfSymbolsAsSentence 
      ( list 'The 'expertise nameOfExpertise 'has 'been 'established. )
    )
    
    #t
    
  );let %code

);define DefineExpertise

( define ( $AddToExpertiseDB nameOfExpertise expertise )
  
  ( let ( ( %n ( $IndexOfExpertiseEntry nameOfExpertise 1 $expertise-DB ) )
        );local
        
    ( if ( < %n 1 ) ; no expertise with name being 'nameOfExpertise' in $expertise-DB 
    
      ; directly add the description of this expertise to DB
      ( set! $expertise-DB  
             ( cons expertise $expertise-DB ) 
      )
      
      ( PrintListOfSymbolsAsSentence 
        ( list 'Sorry. 'There 'is 'already 'an 'expertise 'named nameOfExpertise 'in 'the 'expertise 'database. )
      )
    
    );if ( < %n 1 ) ; i.e., if there is no expertise with such a name in DB
  
  );let %n

);define $AddToExpertiseDB

( define ( $IndexOfExpertiseEntry nameOfExpertise currentIndex list-of-expertise )

; anyone (with the sole exception of $IndexOfExpertiseEntry) who calls this function should pass 1 as 'currentIndex'
; return value of -1 means "not in the given list-of-expertise"
;
; terminology : the index of 'c' in '(a b c d)' is 3 (and not 2)

  ; assert : the index of first element (of list-of-expertise) in the ORIGINAL LIST is 'currentIndex'

  ( cond ( ( null? list-of-expertise ) 
           -1 
         )
  
         ( ( equal? ( car ( car list-of-expertise ) ) 
                    nameOfExpertise 
           )
           currentIndex
         )
         
         ( else ; 'nameOfExpertise' is not the first one of list-of-expertise
         
           ( $IndexOfExpertiseEntry nameOfExpertise 
                                    ( + 1 currentIndex ) 
                                    ( cdr list-of-expertise ) 
           )
           
         );else
         
  );cond

);define $IndexOfExpertiseEntry

( define ruleList-Exaggerated

  ; '( ( ( DivisibleBy n 15 )
  ;      ( + n 150 )
  ;    )
  ;    ( ( DivisibleBy n 5 )
  ;      ( + n 50 )
  ;    )
  ;    ( ( DivisibleBy n 4 )
  ;      ( + n 40 )
  ;    )
  ;    ( else
  ;      ( + n n )
  ;    )
  ;  )
   
  '( ( ( >= n 300000 )               ; condition
     
       ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
             );local
       
         ( cond   
                
           ( ( and ( <= 500000 %p ) ( <= %p 800000 ) 
             )
             
             #t ; OK
           )
           
           ( ( < %p 500000 )
           
             ( cond
               ( ( not ( TopSize? ) )
                 ( UpgradeSize )
               )
               ( ( not ( TopPrice? ) )
                 ( UpgradePrice )
               )
               ( ( not ( TopQuality? ) )
                 ( UpgradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; %p < 500000
           
           ( ( < 800000 %p )
           
             ( cond
               ( ( not ( BottomSize? ) )
                 ( DowngradeSize )
               )
               ( ( not ( BottomPrice? ) )
                 ( DowngradePrice )
               )
               ( ( not ( BottomQuality? ) )
                 ( DowngradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; 800000 < %p
           
           ; no ELSE
           
         );cond
         
         ( TransactionState )
         
       );let %p
           
     ) ; condition-action pair 1 with condition : n >= 200000
     
     ( ( >= n 200000 )               ; condition
     
       ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
             );local
       
         ( cond   
                
           ( ( and ( <= 400000 %p ) ( <= %p 600000 ) 
             )
             
             #t ; OK
           )
           
           ( ( < %p 400000 )
           
             ( cond
               ( ( not ( TopSize? ) )
                 ( UpgradeSize )
               )
               ( ( not ( TopPrice? ) )
                 ( UpgradePrice )
               )
               ( ( not ( TopQuality? ) )
                 ( UpgradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; %p < 400000
           
           ( ( < 600000 %p )
           
             ( cond
               ( ( not ( BottomSize? ) )
                 ( DowngradeSize )
               )
               ( ( not ( BottomPrice? ) )
                 ( DowngradePrice )
               )
               ( ( not ( BottomQuality? ) )
                 ( DowngradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; 600000 < %p
           
           ; no ELSE
           
         );cond
         
         ( TransactionState )
         
       );let %p ; action
           
     ) ; condition-action pair 2 ; with condition : n >= 100000
     
     ( ( >= n 100000 )               ; condition
     
       ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
             );local
       
         ( cond   
                
           ( ( and ( <= 300000 %p ) ( <= %p 400000 ) 
             )
             
             #t ; OK
           )
           
           ( ( < %p 300000 )
           
             ( cond
               ( ( not ( TopSize? ) )
                 ( UpgradeSize )
               )
               ( ( not ( TopPrice? ) )
                 ( UpgradePrice )
               )
               ( ( not ( TopQuality? ) )
                 ( UpgradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; %p < 300000
           
           ( ( < 400000 %p )
           
             ( cond
               ( ( not ( BottomSize? ) )
                 ( DowngradeSize )
               )
               ( ( not ( BottomPrice? ) )
                 ( DowngradePrice )
               )
               ( ( not ( BottomQuality? ) )
                 ( DowngradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; 400000 < %p
           
           ; no ELSE
           
         );cond
         
         ( TransactionState )
         
       );let %p ; action
           
     ) ; condition-action pair 3 ; with condition : n >= 200000
     
     ( else                         ; condition ( n < 200000 )
     
       ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
             );local
       
         ( cond   
                
           ( ( and ( <= 200000 %p ) ( <= %p 300000 ) 
             )
             
             #t ; OK
           )
           
           ( ( < %p 200000 )
           
             ( cond
               ( ( not ( TopSize? ) )
                 ( UpgradeSize )
               )
               ( ( not ( TopPrice? ) )
                 ( UpgradePrice )
               )
               ( ( not ( TopQuality? ) )
                 ( UpgradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; %p < 200000
           
           ( ( < 300000 %p )
           
             ( cond
               ( ( not ( BottomSize? ) )
                 ( DowngradeSize )
               )
               ( ( not ( BottomPrice? ) )
                 ( DowngradePrice )
               )
               ( ( not ( BottomQuality? ) )
                 ( DowngradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; 300000 < %p
           
           ; no ELSE
           
         );cond
         
         ( TransactionState )
         
       );let %p ; action
           
     ) ; condition-action pair 3 ; with condition : else (i.e., n < 200000)
    
   ) ; list of rules
   
); define ruleList-Exaggerated

( DefineExpertise 'Exaggerated ruleList-Exaggerated )

( define rule-139

  '( ( DivisibleBy n 3 )
     ( begin ( UpgradeQuality ) ( TransactionState ) )
   )
   
); define rule-139

                                ; WithNthRuleReplaced n ruleList withThisRule
( DefineExpertise 'Expertise-02 ( WithNthRuleReplaced 1 ruleList-Exaggerated rule-139 )
)

( DefineExpertise 'Expertise-03 
                  ; WithNthRuleReplaced n ruleList withThisRule
                  ( WithNthRuleReplaced 2
                                        ruleList-Exaggerated 
                                        ( Rule
                                          '( DivisibleBy n 7 )
                                          '( begin ( DowngradePrice ) ( TransactionState ) )
                                        ) 
                  )
)

( define ( ListExpertiseNames )

; print the list of expertise-names for all expertise stored in $expertise-DB

  ( let ( ( %length ( ListLength $expertise-DB ) )
        );local
        
    ( if ( < %length 1 )
    
         ( begin
           ( display-string "The expertise database is currently empty" )
           #t
         )
         
         ( $ListExpertiseNames $expertise-DB )
         
    );if %length < 1
    
  );let %length
    
);define ListExpertiseNames

( define ( $ListExpertiseNames expertise-DB )

; print the list of expertise in 'expertis-DB'
; prerequisite: length of 'expertise-DB' >= 1

  ( display-string ( symbol->string ( car ( car expertise-DB ) ) 
                   )
  )
  ( newline )
  
  ( let ( ( %remaining-expertise ( cdr expertise-DB ) )
        );local

    ( if ( null? %remaining-expertise )
         #t
         ( $ListExpertiseNames %remaining-expertise )
    );if
    
  );let %remaining-expertise

);define $ListExpertiseNames

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( define ( ExpertSystemShell )

  ( display-string "------------------\n" )
  
  ( display-string
  
    ( string-append
      "Available choices are\n"
      "1 or DefineExpertise ,\n"
      "2 or RemoveExpertise ,\n"
      "3 or ListExpertiseNames ,\n"
      "4 or ListRuleSet ,\n"
      "5 or ReplaceRuleSet ,\n"
      "6 or ReplaceRuleOfRuleSet ,\n"
      "7 or Quit or quit ;\n"
      "Please enter the number (or item-name) of your choice > "
    )
    
  );display-string
  
  ( let ( ( %userChoice '() )
        );locals
  
    ( set! %userChoice (read))
    
    ( if ( or ( equal? %userChoice 7 )
              ( equal? %userChoice 'Quit )
              ( equal? %userChoice 'quit )
         )
         
         'Bye!
         
         ( begin
           ( cond ( ( or ( equal? %userChoice 1 )
                         ( equal? %userChoice 'DefineNewExpertise )
                    )
                    ( DoDefineNewExpertise )
                  )
                  ( ( or ( equal? %userChoice 2 )
                         ( equal? %userChoice 'RemoveExpertise )
                    )
                    ( DoRemoveExpertise )
                  )
                  ( ( or ( equal? %userChoice 3 )
                         ( equal? %userChoice 'ListExpertiseNames )
                    )
                    ( ListExpertiseNames )
                  )
                  ( ( or ( equal? %userChoice 4 )
                         ( equal? %userChoice 'ListRuleSet )
                    )
                    ( ListRuleSet )
                  )
                  ( ( or ( equal? %userChoice 5 )
                         ( equal? %userChoice 'ReplaceRuleSet )
                    )
                    ( DoReplaceRuleSet )
                  )
                  ( ( or ( equal? %userChoice 6 )
                         ( equal? %userChoice 'ReplaceRuleOfRuleSet )
                    )
                    ( DoReplaceRuleOfRuleSet )
                  )
                  ( else 
                    ( display-string "Sorry! The choice you give is not in the list of choices.\n" ) 
                  )
           );cond
           
           ( ExpertSystemShell )
           
         );begin
         
    );if 7 or Quit
    
  );let %userChoice
  
);ExpertSystemShell

( define ( DoDefineNewExpertise )

  ( let ( ( %nameOfExpertise '() )
          ( %listOfRules '() )
        );locals
        
    ( display-string "Name of the new expertise > " )
    ( set! %nameOfExpertise ( read ) )
    
    ( let ( ( %n ( $IndexOfExpertiseEntry %nameOfExpertise 1 $expertise-DB ) )
          );local
          
      ( if ( < %n 1 ) ; there is no expertise with name being '%nameOfExpertise' in $expertise-DB 
                      ; therefore, it is OK to add this new one into $expertise-DB
        ( begin
        
          ( display-string "The set of rules to be used by the new expertise > " )
          ( set! %listOfRules ( read ) )
          
          ; ( DefineExpertise nameOfExpertise listOfRules )
          ( DefineExpertise %nameOfExpertise %listOfRules )
    
        );begin
        
        ; %n >= 1
    
        ( PrintListOfSymbolsAsSentence 
          ( list 'Sorry. 'There 'is 'already 'an 'expertise 'named %nameOfExpertise 'in 'the 'expertise 'database. )
        )
        
      );if there is no expertise with name being '%nameOfExpertise' in $expertise-DB
      
    );let %n
      
  );let %nameOfExpertise, %listOfRules

);define DoDefineNewExpertise

( define ( DoRemoveExpertise )

  ( let ( ( %nameOfExpertise '() )
        );locals

    ( display-string "Name of the expertise to remove > " )
    ( set! %nameOfExpertise ( read ) )
    
    ( let ( ( %n ( $IndexOfExpertiseEntry %nameOfExpertise 1 $expertise-DB ) )
          );local
          
      ( if ( < %n 1 ) ; no expertise with name being '%nameOfExpertise' in $expertise-DB 
      
        ( PrintListOfSymbolsAsSentence 
          ( list 'Sorry. 'There 'is 'no 'expertise 'named %nameOfExpertise 'in 'the 'expertise 'database. )
        )
        
        ; %n >= 1 ; i.e., found the expertise named %nameOfExpertise in $expertise-DB
      
        ( begin
        
          ; 1. remove the description of this expertise from expertise-DB
          
          ( set! $expertise-DB 
                 ; ( $WithExpertiseRemoved nameOfExpertise list-of-expertise )
                 ( $WithExpertiseRemoved %nameOfExpertise $expertise-DB ) 
          )
          
          ; 2. somewhat unbound the function-binding of the symbol '%nameOfExpertise'
          
          ( eval ( list 'set! %nameOfExpertise ''() ) ) 
          
          ; 3. feedback msg
    
          ( PrintListOfSymbolsAsSentence 
            ( list 'The 'expertise 'named %nameOfExpertise 'has 'been 'removed 'from 'the 'expertise 'database. )
          )
          
        );begin
        
      );if no expertise with name being '%nameOfExpertise' in $expertise-DB
      
    );let %n
    
  );let %nameOfExpertise
    
);define DoRemoveExpertise

( define ( $WithExpertiseRemoved nameOfExpertise list-of-expertise )

  ( cond ( ( null? list-of-expertise )
           '()
         )
         
         ( ( equal? ( car ( car list-of-expertise ) ) nameOfExpertise )
           ( cdr list-of-expertise ) ; removed
         )
         
         ( else
         
           ( cons ( car list-of-expertise )
                  ( $WithExpertiseRemoved nameOfExpertise 
                                          ( cdr list-of-expertise ) 
                  )
           )
           
         );else
         
  );cond
  
);define $WithExpertiseRemoved

( define ( ListRuleSet )

  ( let ( ( %expertiseName '() )
        );loals

    ( display-string "Please give the name of the expertise > " )
    ( set! %expertiseName ( read ) )
    
    ; ( RuleSetOf expertiseName )
    ( write ( RuleSetOf %expertiseName ) )
    ( newline )
  
  );let %expertiseName

);define ListRuleSet

( define ( DoReplaceRuleSet )

  ( let ( ( %nameOfExpertise '() )
          ( %listOfRules '() )
        );local
        
    ( display-string "Name of the expertise you want to replace its rule-set > " )
    ( set! %nameOfExpertise ( read ) )
    
    ( display-string "The new set of rules to be used by this expertise > " )
    ( set! %listOfRules ( read ) )
    
    ; ( $ReplaceRuleSet nameOfExpertise listOfRules )
    ( $ReplaceRuleSet %nameOfExpertise %listOfRules )
    
  );let %nameOfExpertise, %listOfRules

);define DoReplaceRuleSet

( define ( $ReplaceRuleSet nameOfExpertise listOfRules )

  ( let ( ( %n ( $IndexOfExpertiseEntry nameOfExpertise 1 $expertise-DB ) )
        );local
        
    ( if ( < %n 1 ) ; no expertise with name being 'nameOfExpertise' in $expertise-DB 
    
      ( PrintListOfSymbolsAsSentence 
        ( list 'There 'is 'no 'expertise 'named nameOfExpertise 'in 'the 'expertise 'database. )
      )
    
      ; got the entry-index of 'nameOfExpertise' in $expertise-DB
      
      ( let ( ( %code
                ( list 'define
                       ( cons nameOfExpertise '( n ) )
                       ( cons 'cond listOfRules )
                )
              )
              ( %expertise
                ( cons nameOfExpertise listOfRules )
              )
            );local-var
            
        ( eval %code ) ; redefine this expertise
        
        ; update its description in the expertise-DB
        
        ( set! $expertise-DB  
               ( WithNthElementOfListReplaced %n $expertise-DB %expertise )
        )
        
        ( PrintListOfSymbolsAsSentence 
          ( list 'The 'rule-set 'of nameOfExpertise 'has 'been 'replaced. )
        )
      
        #t
        
      );let %code, %expertise
    
    );if %n < 1
    
  );let %n

);define $ReplaceRuleSet

( define ( DoReplaceRuleOfRuleSet )

  ( let ( ( %nameOfExpertise '() )
          ( %whichRule '() )
          ( %rule '() )
        );local
        
    ( display-string "Name of the expertise you want to replace its rule > " )
    ( set! %nameOfExpertise ( read ) )
    
    ( display-string "Ordering of the rule that is to be replaced - Please enter a number (e.g., 3) > " )
    ( set! %whichRule ( read ) )
    
    ( display-string "The new rule to be used in its place > " )
    ( set! %rule ( read ) )
    
    ; ( $ReplaceRuleOfRuleSet nameOfExpertise whichRule rule )
    ( $ReplaceRuleOfRuleSet %nameOfExpertise %whichRule %rule )
    
  );let %nameOfExpertise, %whichRule, %rule

);define DoReplaceRuleOfRuleSet

( define ( $ReplaceRuleOfRuleSet nameOfExpertise whichRule newRule )

  ( let ( ( %n ( $IndexOfExpertiseEntry nameOfExpertise 1 $expertise-DB ) )
        );local
        
    ( if ( < %n 1 ) ; no expertise with name being 'nameOfExpertise' in $expertise-DB 
    
      ( PrintListOfSymbolsAsSentence 
        ( list 'There 'is 'no 'expertise 'named nameOfExpertise 'in 'the 'expertise 'database. )
      )
    
      ; got the entry-index of 'nameOfExpertise' in $expertise-DB
      
      ( let ( ( %existingRuleSet ( RuleSetOf nameOfExpertise ) )
              ( %newRuleSet '() )
            );locals
      
        ( if ( < ( ListLength %existingRuleSet ) whichRule )
             
             ( PrintListOfSymbolsAsSentence 
               ( list 'The 'expertise 'named nameOfExpertise 'does 'not 'have 'this 'many 'rules. )
             )
              
             ( begin
             
               ( set! %newRuleSet
                      ; ( WithNthElementOfListReplaced n aList new-element )
                      ( WithNthElementOfListReplaced whichRule %existingRuleSet newRule )
               )
        
               ( let ( ( %code
                         ( list 'define
                                ( cons nameOfExpertise '( n ) )
                                ( cons 'cond %newRuleSet )
                         )
                       )
                       ( %revisedExpertise
                         ( cons nameOfExpertise %newRuleSet )
                       )
                     );local-var
                     
                 ( eval %code ) ; redefine this expertise
                 
                 ; update its description in the expertise-DB
                 
                 ( set! $expertise-DB  
                        ; ( WithNthElementOfListReplaced n aList new-element )
                        ( WithNthElementOfListReplaced %n $expertise-DB %revisedExpertise )
                 )
                 
                 ( PrintListOfSymbolsAsSentence 
                   ( list 'The 'specified 'rule 'of nameOfExpertise 'has 'been 'replaced. )
                 )
               
                 #t
                 
               );let %code, %revisedExpertise
               
             );begin
             
        );if ( ListLength %existingRuleSet ) < whichRule
        
      );let %existingRuleSet %newRuleSet
    
    );if %n < 1
    
  );let %n

);define $ReplaceRuleOfRuleSet

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Utilities ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

( ExpertSystemShell )
3 ; ListExpertiseNames
quit
(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)
(OverSpent 251476)
(Exaggerated 251476)
(Exaggerated 251476)
(OverSpent 78254)
(OverSpent 78254)
(Exaggerated 78254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Exaggerated 38254)
(Expertise-02 38454)
(Expertise-03 38556)
(Expertise-03 38556)
(Expertise-03 38557)
(Exaggerated 38255)
(Expertise-02 38255)

(ExpertSystemShell)
1 ; DefineExpertise
Modest ; name of the new expertise

; the set of rules to be used by the expertise

   ( ( ( >= n 300000 )               ; condition
     
       ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
             );local
       
         ( cond   
                
           ( ( and ( <= 200000 %p ) ( <= %p 300000 ) 
             )
             
             #t ; OK
           )
           
           ( ( < %p 200000 )
           
             ( cond
               ( ( not ( TopSize? ) )
                 ( UpgradeSize )
               )
               ( ( not ( TopPrice? ) )
                 ( UpgradePrice )
               )
               ( ( not ( TopQuality? ) )
                 ( UpgradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; %p < 200000
           
           ( ( < 300000 %p )
           
             ( cond
               ( ( not ( BottomSize? ) )
                 ( DowngradeSize )
               )
               ( ( not ( BottomPrice? ) )
                 ( DowngradePrice )
               )
               ( ( not ( BottomQuality? ) )
                 ( DowngradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; 300000 < %p
           
           ; no ELSE
           
         );cond
         
         ( TransactionState )
         
       );let %p
           
     ) ; condition-action pair 1 with condition : n >= 200000
     
     ( ( >= n 200000 )               ; condition
     
       ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
             );local
       
         ( cond   
                
           ( ( and ( <= 100000 %p ) ( <= %p 200000 ) 
             )
             
             #t ; OK
           )
           
           ( ( < %p 100000 )
           
             ( cond
               ( ( not ( TopSize? ) )
                 ( UpgradeSize )
               )
               ( ( not ( TopPrice? ) )
                 ( UpgradePrice )
               )
               ( ( not ( TopQuality? ) )
                 ( UpgradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; %p < 100000
           
           ( ( < 200000 %p )
           
             ( cond
               ( ( not ( BottomSize? ) )
                 ( DowngradeSize )
               )
               ( ( not ( BottomPrice? ) )
                 ( DowngradePrice )
               )
               ( ( not ( BottomQuality? ) )
                 ( DowngradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; 200000 < %p
           
           ; no ELSE
           
         );cond
         
         ( TransactionState )
         
       );let %p ; action
           
     ) ; condition-action pair 2 ; with condition : n >= 100000
     
     ( ( >= n 100000 )               ; condition
     
       ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
             );local
       
         ( cond   
                
           ( ( and ( <= 70000 %p ) ( <= %p 100000 ) 
             )
             
             #t ; OK
           )
           
           ( ( < %p 70000 )
           
             ( cond
               ( ( not ( TopSize? ) )
                 ( UpgradeSize )
               )
               ( ( not ( TopPrice? ) )
                 ( UpgradePrice )
               )
               ( ( not ( TopQuality? ) )
                 ( UpgradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; %p < 70000
           
           ( ( < 100000 %p )
           
             ( cond
               ( ( not ( BottomSize? ) )
                 ( DowngradeSize )
               )
               ( ( not ( BottomPrice? ) )
                 ( DowngradePrice )
               )
               ( ( not ( BottomQuality? ) )
                 ( DowngradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; 100000 < %p
           
           ; no ELSE
           
         );cond
         
         ( TransactionState )
         
       );let %p ; action
           
     ) ; condition-action pair 3 ; with condition : n >= 100000
     
     ( else                         ; condition ( n < 100000 )
     
       ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
             );local
       
         ( cond   
                
           ( ( and ( <= 30000 %p ) ( <= %p 70000 ) 
             )
             
             #t ; OK
           )
           
           ( ( < %p 30000 )
           
             ( cond
               ( ( not ( TopSize? ) )
                 ( UpgradeSize )
               )
               ( ( not ( TopPrice? ) )
                 ( UpgradePrice )
               )
               ( ( not ( TopQuality? ) )
                 ( UpgradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; %p < 30000
           
           ( ( < 70000 %p )
           
             ( cond
               ( ( not ( BottomSize? ) )
                 ( DowngradeSize )
               )
               ( ( not ( BottomPrice? ) )
                 ( DowngradePrice )
               )
               ( ( not ( BottomQuality? ) )
                 ( DowngradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; 70000 < %p
           
           ; no ELSE
           
         );cond
         
         ( TransactionState )
         
       );let %p ; action
           
     ) ; condition-action pair 4 ; with condition : else (i.e., n < 100000)
    
   ) ; list of rules
quit

(ResetTransactionState)

(Modest 35021)
(Modest 35021)
(Modest 35021) ; "quality : 3 size : 1 price : 3 ProductIndex : 4"

(Modest 125871) ; "quality : 3 size : 1 price : 2 ProductIndex : 3"
(Modest 125871)

(ResetTransactionState)

(Modest 125871)
(Modest 125871)
(Modest 125871) ; "quality : 3 size : 1 price : 2 ProductIndex : 3"
(Modest 125871)
(Modest 35021) ; "quality : 3 size : 1 price : 2 ProductIndex : 3"

(ResetTransactionState)

(Modest 125870) ; "quality : 3 size : 2 price : 3 ProductIndex : 5"
(Modest 125870)

(ResetTransactionState)

(Modest 125872)
(Modest 125872) ; "quality : 3 size : 1 price : 3 ProductIndex : 4"
(Modest 125872)

(ExpertSystemShell)
6 ; ReplaceRuleOfRuleSet
Modest ; name of the expertise
3 ; orderting of the rule to be replaced

; the new (3rd) rule

     ( ( >= n 100000 )               ; condition
     
       ( let ( ( %p ( PriceTag n ) )  ; action ; it can be multiple actions
             );local
       
         ( cond   
                
           ( ( and ( <= 80000 %p ) ( <= %p 150000 ) 
             )
             
             #t ; OK
           )
           
           ( ( < %p 80000 )
           
             ( cond
               ( ( not ( TopSize? ) )
                 ( UpgradeSize )
               )
               ( ( not ( TopPrice? ) )
                 ( UpgradePrice )
               )
               ( ( not ( TopQuality? ) )
                 ( UpgradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; %p < 80000
           
           ( ( < 150000 %p )
           
             ( cond
               ( ( not ( BottomSize? ) )
                 ( DowngradeSize )
               )
               ( ( not ( BottomPrice? ) )
                 ( DowngradePrice )
               )
               ( ( not ( BottomQuality? ) )
                 ( DowngradeQuality )
               )
               ; no ELSE 
             );cond
             
           ) ; 150000 < %p
           
           ; no ELSE
           
         );cond
         
         ( TransactionState )
         
       );let %p ; action
           
     ) ; condition-action pair 3 ; with condition : n >= 100000
quit

(ResetTransactionState)

(Modest 125871) ; "quality : 3 size : 2 price : 3 ProductIndex : 5"
(Modest 125871)
(Modest 125870) ; "quality : 3 size : 2 price : 3 ProductIndex : 5"
(Modest 125872) ; "quality : 3 size : 2 price : 3 ProductIndex : 5"

(Modest 254865) ; "quality : 3 size : 2 price : 3 ProductIndex : 5"

(Modest 425187) ; "quality : 3 size : 3 price : 3 ProductIndex : 6"
(Modest 425187)

(Modest 425188) ; "quality : 3 size : 3 price : 3 ProductIndex : 6"

(Modest 1000000) ; "quality : 3 size : 2 price : 3 ProductIndex : 5"
(Modest 1000000)

(exit)
